// ========================================
// Dual Camera On-Demand Stream Integration
// ========================================

// Configuration
const CONFIG = {
    streamApiUrl: 'https://stream-api.dwtb-solar-canopy.org',
    apiKey: 'bb6104ec02362103cf42e69567d1f724f577b46f3789ec162893cdb906c587c2',
    cameras: {
        cam1: {
            id: 'cam1',
            name: 'Camera 1',
            playbackUrl: 'https://customer-i32my3qs0ldoeuy3.cloudflarestream.com/c0c327782cd0701b6d78dd33526706e3/manifest/video.m3u8'
        },
        cam2: {
            id: 'cam2',
            name: 'Camera 2',
            playbackUrl: 'https://customer-i32my3qs0ldoeuy3.cloudflarestream.com/4aabdd6cb03fb70149fb583b3ffa66bd/manifest/video.m3u8'
        }
    },
    streamDuration: 300000, // 5 minutes in milliseconds
    startupDelay: 15000, // Wait 15 seconds for stream to initialize
    statusCheckInterval: 10000, // Check status every 10 seconds
    sensorUpdateInterval: 10000 // Update sensor data every 10 seconds
};

// State management for each camera
const cameraStates = {
    cam1: {
        isStreaming: false,
        streamStartTime: null,
        statusCheckTimer: null,
        autoStopTimer: null,
        hlsInstance: null
    },
    cam2: {
        isStreaming: false,
        streamStartTime: null,
        statusCheckTimer: null,
        autoStopTimer: null,
        hlsInstance: null
    }
};

// ========================================
// API Functions
// ========================================

async function startStream(cameraId) {
    try {
        const response = await fetch(`${CONFIG.streamApiUrl}/stream/start/${cameraId}?api_key=${CONFIG.apiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        const data = await response.json();
        console.log(`${cameraId} stream start response:`, data);
        
        if (data.status === 'started' || data.status === 'starting' || data.status === 'already_running') {
            return true;
        } else {
            console.error(`Failed to start ${cameraId}:`, data);
            return false;
        }
    } catch (error) {
        console.error(`Error starting ${cameraId}:`, error);
        return false;
    }
}

async function checkStreamStatus(cameraId) {
    try {
        const response = await fetch(`${CONFIG.streamApiUrl}/stream/status/${cameraId}?api_key=${CONFIG.apiKey}`);
        const data = await response.json();
        return data.stream_active;
    } catch (error) {
        console.error(`Error checking ${cameraId} status:`, error);
        return false;
    }
}

// ========================================
// UI Functions
// ========================================

function updatePlayButton(cameraId, state) {
    const playButton = document.getElementById(`play-button-${cameraId}`);
    const statusText = document.getElementById(`stream-status-${cameraId}`);
    const cameraName = CONFIG.cameras[cameraId].name;
    
    switch(state) {
        case 'ready':
            playButton.disabled = false;
            playButton.textContent = `‚ñ∂Ô∏è Play ${cameraName}`;
            playButton.classList.remove('loading', 'streaming');
            if (statusText) statusText.textContent = 'Ready to stream';
            break;
            
        case 'loading':
            playButton.disabled = true;
            playButton.textContent = '‚è≥ Starting...';
            playButton.classList.add('loading');
            if (statusText) statusText.textContent = 'Initializing stream...';
            break;
            
        case 'streaming':
            playButton.disabled = true;
            playButton.textContent = 'üî¥ Live';
            playButton.classList.add('streaming');
            playButton.classList.remove('loading');
            if (statusText) {
                const timeRemaining = Math.floor((CONFIG.streamDuration - (Date.now() - cameraStates[cameraId].streamStartTime)) / 1000);
                statusText.textContent = `Streaming (${Math.floor(timeRemaining / 60)}:${(timeRemaining % 60).toString().padStart(2, '0')} remaining)`;
            }
            break;
            
        case 'ended':
            playButton.disabled = false;
            playButton.textContent = `‚ñ∂Ô∏è Restart ${cameraName}`;
            playButton.classList.remove('loading', 'streaming');
            if (statusText) statusText.textContent = 'Stream ended. Click to restart.';
            break;
            
        case 'error':
            playButton.disabled = false;
            playButton.textContent = '‚ö†Ô∏è Try Again';
            playButton.classList.remove('loading', 'streaming');
            if (statusText) statusText.textContent = 'Error. Try again.';
            break;
    }
}

function updateRemainingTime(cameraId) {
    const state = cameraStates[cameraId];
    if (!state.isStreaming || !state.streamStartTime) return;
    
    const elapsed = Date.now() - state.streamStartTime;
    const remaining = CONFIG.streamDuration - elapsed;
    
    if (remaining <= 0) {
        handleStreamEnded(cameraId);
        return;
    }
    
    const statusText = document.getElementById(`stream-status-${cameraId}`);
    if (statusText) {
        const minutes = Math.floor(remaining / 60000);
        const seconds = Math.floor((remaining % 60000) / 1000);
        statusText.textContent = `üî¥ Live (${minutes}:${seconds.toString().padStart(2, '0')} remaining)`;
    }
}

// ========================================
// Stream Management
// ========================================

function startStatusChecking(cameraId) {
    const state = cameraStates[cameraId];
    
    // Wait 20 seconds before starting status checks
    setTimeout(() => {
        state.statusCheckTimer = setInterval(async () => {
            const isActive = await checkStreamStatus(cameraId);
            if (!isActive && state.isStreaming) {
                console.log(`${cameraId} stopped unexpectedly`);
                handleStreamEnded(cameraId);
            }
        }, CONFIG.statusCheckInterval);
    }, 20000);
    
    // Update remaining time display every second
    const timeUpdateTimer = setInterval(() => {
        if (state.isStreaming) {
            updateRemainingTime(cameraId);
        } else {
            clearInterval(timeUpdateTimer);
        }
    }, 1000);
}

function stopStatusChecking(cameraId) {
    const state = cameraStates[cameraId];
    if (state.statusCheckTimer) {
        clearInterval(state.statusCheckTimer);
        state.statusCheckTimer = null;
    }
    if (state.autoStopTimer) {
        clearTimeout(state.autoStopTimer);
        state.autoStopTimer = null;
    }
}

function handleStreamEnded(cameraId) {
    console.log(`${cameraId} stream ended`);
    
    // Stop the HLS player
    stopHLSPlayer(cameraId);
    
    // Update state
    const state = cameraStates[cameraId];
    state.isStreaming = false;
    state.streamStartTime = null;
    stopStatusChecking(cameraId);
    
    // Update UI
    updatePlayButton(cameraId, 'ended');
}

async function handlePlayButtonClick(cameraId) {
    console.log(`${cameraId} play button clicked`);
    
    // Update UI to loading state
    updatePlayButton(cameraId, 'loading');
    
    try {
        // Start the stream on RPi5
        const streamStarted = await startStream(cameraId);
        
        if (!streamStarted) {
            updatePlayButton(cameraId, 'error');
            alert(`Failed to start ${CONFIG.cameras[cameraId].name}. Please try again.`);
            return;
        }
        
        // Wait for stream to initialize
        console.log(`Waiting ${CONFIG.startupDelay}ms for ${cameraId} to start...`);
        await new Promise(resolve => setTimeout(resolve, CONFIG.startupDelay));
        
        // Update state
        const state = cameraStates[cameraId];
        state.isStreaming = true;
        state.streamStartTime = Date.now();
        
        // Initialize HLS player
        const playbackUrl = CONFIG.cameras[cameraId].playbackUrl;
        console.log(`Initializing ${cameraId} HLS player with URL:`, playbackUrl);
        const playerStarted = initializeHLSPlayer(cameraId, playbackUrl);
        
        if (!playerStarted) {
            console.error(`Failed to initialize ${cameraId} video player`);
            updatePlayButton(cameraId, 'error');
            alert(`Failed to initialize ${CONFIG.cameras[cameraId].name} player. Please try again.`);
            state.isStreaming = false;
            state.streamStartTime = null;
            return;
        }
        
        // Update UI
        updatePlayButton(cameraId, 'streaming');
        
        // Start monitoring stream status
        startStatusChecking(cameraId);
        
        // Set timer to handle automatic stop after 5 minutes
        state.autoStopTimer = setTimeout(() => {
            handleStreamEnded(cameraId);
        }, CONFIG.streamDuration);
        
    } catch (error) {
        console.error(`Error in ${cameraId} play button handler:`, error);
        updatePlayButton(cameraId, 'error');
        alert(`An error occurred with ${CONFIG.cameras[cameraId].name}. Please try again.`);
    }
}

// ========================================
// HLS Player Setup
// ========================================

function initializeHLSPlayer(cameraId, url) {
    const videoPlayer = document.getElementById(`video-player-${cameraId}`);
    if (!videoPlayer) {
        console.error(`Video player element not found for ${cameraId}`);
        return false;
    }

    const state = cameraStates[cameraId];

    // Destroy existing HLS instance if any
    if (state.hlsInstance) {
        state.hlsInstance.destroy();
        state.hlsInstance = null;
    }

    // Check if browser supports native HLS (Safari/iOS)
    if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
        console.log(`Using native HLS support for ${cameraId}`);
        videoPlayer.src = url;
        videoPlayer.play().catch(err => {
            console.error(`Error playing ${cameraId}:`, err);
            updatePlayButton(cameraId, 'error');
            alert(`Failed to play ${CONFIG.cameras[cameraId].name}. Please try again.`);
        });
        return true;
    }
    // Use HLS.js for other browsers
    else if (window.Hls && Hls.isSupported()) {
        console.log(`Using HLS.js for ${cameraId}`);
        state.hlsInstance = new Hls({
            enableWorker: true,
            lowLatencyMode: false,
            
            liveSyncDurationCount: 7,
            liveMaxLatencyDurationCount: 15,
            liveDurationInfinity: true,
            
            maxBufferLength: 60,
            maxMaxBufferLength: 120,
            backBufferLength: 90,
            
            maxBufferSize: 60 * 1000 * 1000,
            maxBufferHole: 1.0,
            
            manifestLoadingTimeOut: 10000,
            manifestLoadingMaxRetry: 10,
            manifestLoadingRetryDelay: 1000,
            
            levelLoadingTimeOut: 10000,
            levelLoadingMaxRetry: 10,
            levelLoadingRetryDelay: 1000,
            
            fragLoadingTimeOut: 20000,
            fragLoadingMaxRetry: 10,
            fragLoadingRetryDelay: 1000,
            
            startPosition: -1
        });

        state.hlsInstance.loadSource(url);
        state.hlsInstance.attachMedia(videoPlayer);

        state.hlsInstance.on(Hls.Events.MANIFEST_PARSED, () => {
            console.log(`${cameraId} HLS manifest parsed, starting playback`);
            
            videoPlayer.play().catch(err => {
                console.error(`Error playing ${cameraId}:`, err);
                updatePlayButton(cameraId, 'error');
                alert(`Failed to play ${CONFIG.cameras[cameraId].name}. Please try again.`);
            });
        });

        state.hlsInstance.on(Hls.Events.ERROR, (event, data) => {
            console.error(`${cameraId} HLS error:`, data);
            if (data.fatal) {
                switch (data.type) {
                    case Hls.ErrorTypes.NETWORK_ERROR:
                        console.log(`${cameraId} network error, attempting recovery...`);
                        state.hlsInstance.startLoad();
                        break;
                    case Hls.ErrorTypes.MEDIA_ERROR:
                        console.log(`${cameraId} media error, attempting recovery...`);
                        state.hlsInstance.recoverMediaError();
                        break;
                    default:
                        console.error(`${cameraId} fatal error, cannot recover`);
                        if (state.isStreaming) {
                            updatePlayButton(cameraId, 'error');
                            alert(`${CONFIG.cameras[cameraId].name} playback error. Please try restarting.`);
                        }
                        break;
                }
            }
        });

        return true;
    } else {
        console.error(`HLS not supported in this browser for ${cameraId}`);
        alert('Your browser does not support HLS video playback.');
        return false;
    }
}

function stopHLSPlayer(cameraId) {
    const videoPlayer = document.getElementById(`video-player-${cameraId}`);
    const state = cameraStates[cameraId];
    
    if (state.hlsInstance) {
        state.hlsInstance.destroy();
        state.hlsInstance = null;
    }
    
    if (videoPlayer) {
        videoPlayer.pause();
        videoPlayer.src = '';
        videoPlayer.load();
    }
}

// ========================================
// Video Player Event Handlers
// ========================================

function setupVideoPlayerEvents(cameraId) {
    const videoPlayer = document.getElementById(`video-player-${cameraId}`);
    if (!videoPlayer) return;
    
    const state = cameraStates[cameraId];
    
    videoPlayer.addEventListener('error', (e) => {
        console.error(`${cameraId} video player error:`, e);
        if (state.isStreaming) {
            // Check if stream ended naturally
            const elapsed = Date.now() - state.streamStartTime;
            
            if (elapsed >= CONFIG.streamDuration - 5000) {
                // Stream ended naturally
                console.log(`${cameraId} stream ended as expected`);
                handleStreamEnded(cameraId);
            } else {
                // Unexpected error
                updatePlayButton(cameraId, 'error');
                alert(`${CONFIG.cameras[cameraId].name} playback error. The stream may have ended unexpectedly.`);
                handleStreamEnded(cameraId);
            }
        }
    });
    
    videoPlayer.addEventListener('ended', () => {
        console.log(`${cameraId} video ended event`);
        if (state.isStreaming) {
            handleStreamEnded(cameraId);
        }
    });
    
    videoPlayer.addEventListener('waiting', () => {
        console.log(`${cameraId} video waiting/buffering...`);
    });
}

// ========================================
// Initialization
// ========================================

function initializeCamera(cameraId) {
    console.log(`Initializing ${cameraId} controls`);
    
    const playButton = document.getElementById(`play-button-${cameraId}`);
    if (playButton) {
        playButton.addEventListener('click', () => handlePlayButtonClick(cameraId));
        updatePlayButton(cameraId, 'ready');
    } else {
        console.error(`Play button not found for ${cameraId}`);
    }
    
    setupVideoPlayerEvents(cameraId);
    
    // Check initial stream status
    checkStreamStatus(cameraId).then(isActive => {
        if (isActive) {
            console.log(`${cameraId} stream is already active`);
        }
    });
}

function initializeStreamControls() {
    console.log('Initializing dual camera stream controls and sensors');
    
    // Initialize cameras
    initializeCamera('cam1');
    initializeCamera('cam2');
    
    // Initialize sensor updates
    startSensorUpdates();
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeStreamControls);
} else {
    initializeStreamControls();
}

// ========================================
// Optional: Manual Controls (for testing)
// ========================================

window.streamControls = {
    startCam1: () => handlePlayButtonClick('cam1'),
    startCam2: () => handlePlayButtonClick('cam2'),
    stopCam1: () => handleStreamEnded('cam1'),
    stopCam2: () => handleStreamEnded('cam2'),
    checkStatus: (cameraId) => checkStreamStatus(cameraId),
    getState: (cameraId) => cameraStates[cameraId]
};

// ========================================
// Sensor Data Functions
// ========================================

let sensorUpdateTimer = null;

async function fetchSensorData() {
    try {
        const response = await fetch(`${CONFIG.streamApiUrl}/sensor/data`);
        const result = await response.json();
        
        if (result.status === 'ok' && result.data) {
            updateSensorDisplay(result.data);
            return true;
        } else {
            console.error('Sensor data error:', result);
            showSensorError('No data available');
            return false;
        }
    } catch (error) {
        console.error('Error fetching sensor data:', error);
        showSensorError('Connection error');
        return false;
    }
}

function updateSensorDisplay(data) {
    const tempElement = document.getElementById('temperature-value');
    const humElement = document.getElementById('humidity-value');
    const statusElement = document.getElementById('sensor-status');
    
    if (data.temperature !== null && data.humidity !== null) {
        // Update values with animation
        if (tempElement) {
            tempElement.textContent = data.temperature.toFixed(1);
            tempElement.classList.add('updated');
            setTimeout(() => tempElement.classList.remove('updated'), 500);
        }
        
        if (humElement) {
            humElement.textContent = data.humidity.toFixed(1);
            humElement.classList.add('updated');
            setTimeout(() => humElement.classList.remove('updated'), 500);
        }
        
        // Update status
        if (statusElement) {
            const updateTime = new Date(data.last_update);
            const timeStr = updateTime.toLocaleTimeString();
            statusElement.textContent = `Last updated: ${timeStr} (${data.sample_count} samples)`;
            statusElement.className = 'sensor-status success';
        }
    } else {
        // Waiting for first reading
        if (statusElement) {
            statusElement.textContent = 'Waiting for sensor data...';
            statusElement.className = 'sensor-status';
        }
    }
}

function showSensorError(message) {
    const statusElement = document.getElementById('sensor-status');
    if (statusElement) {
        statusElement.textContent = `Error: ${message}`;
        statusElement.className = 'sensor-status error';
    }
}

function startSensorUpdates() {
    console.log('Starting sensor data updates');
    
    // Fetch immediately
    fetchSensorData();
    
    // Then fetch every 10 seconds
    sensorUpdateTimer = setInterval(() => {
        fetchSensorData();
    }, CONFIG.sensorUpdateInterval);
}

function stopSensorUpdates() {
    if (sensorUpdateTimer) {
        clearInterval(sensorUpdateTimer);
        sensorUpdateTimer = null;
    }
}

// Add to initialization
function initializeStreamControls() {
    console.log('Initializing dual camera stream controls and sensors');
    
    // Initialize cameras
    initializeCamera('cam1');
    initializeCamera('cam2');
    
    // Initialize sensor updates
    startSensorUpdates();
}

// Expose sensor controls for testing
window.sensorControls = {
    fetch: fetchSensorData,
    start: startSensorUpdates,
    stop: stopSensorUpdates
};
